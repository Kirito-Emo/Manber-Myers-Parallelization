// Created by Emanuele (https://github.com/Kirito-Emo)

#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <omp.h>
#include <sstream>
#include <string>
#include <vector>
#include "suffix_array.h"

// Default baseline CSV (generated by sequential_measure.sh)
// Format expected: "size,avg_time_compute_pure_s" with size like "100MB"
static double load_seq_baseline_for_mb(int mb)
{
    // Environment override
    const char *env = std::getenv("SEQ_BASELINE_CSV");
    std::string path = env ? std::string(env) : "../perf-stats/seq_measurements/seq_summary.csv";

    std::ifstream fin(path);
    if (!fin)
        return -1.0;

    std::string line;
    // Skip header
    if (!std::getline(fin, line))
        return -1.0;

    const std::string key = std::to_string(mb) + "MB";
    while (std::getline(fin, line))
    {
        std::stringstream ss(line);
        std::string size, avg;
        if (!std::getline(ss, size, ','))
            continue;
        if (!std::getline(ss, avg, ','))
            continue;
        if (size == key)
        {
            try
            {
                return std::stod(avg);
            }
            catch (...)
            {
                return -1.0;
            }
        }
    }
    return -1.0;
}

static inline double mb_from_bytes(size_t n) { return static_cast<double>(n) / (1024.0 * 1024.0); }

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        std::cerr << "Usage: " << argv[0] << " <size-in-MB>\n";
        return 1;
    }

    // Parse the desired size in MB from command line
    const int mb = std::stoi(argv[1]);
    if (mb != 1 && mb != 50 && mb != 100 && mb != 200 && mb != 500)
    {
        std::cerr << "Error: size must be one of 1, 50, 100, 200 or 500 MB.\n";
        return 1;
    }

    const size_t n = static_cast<size_t>(mb) * 1024 * 1024;
    const int p_threads = omp_get_max_threads();

    // Measure file I/O
    double t0 = omp_get_wtime();
    std::vector<uint8_t> text(n);
    // Construct filename based on MB size
    std::string filename = "../random_strings/string_" + std::to_string(mb) + "MB.bin";
    std::ifstream fin(filename, std::ios::binary);
    if (!fin)
    {
        std::cerr << "Error: could not open file " << filename << "\n";
        return 1;
    }

    fin.read(reinterpret_cast<char *>(text.data()), n);
    if (static_cast<size_t>(fin.gcount()) != n)
    {
        std::cerr << "Error: file size mismatch. Expected " << n << " bytes.\n";
        return 1;
    }

    fin.close();
    double t1 = omp_get_wtime();
    const double time_io = t1 - t0;

    // Measure host memory allocation overhead
    t0 = omp_get_wtime();
    // Allocate workspace for SA + LCP
    std::vector<int> sa(n), rank(n), cnt(n), next(n), lcp(n);
    std::vector<bool> bh(n), b2h(n);
    t1 = omp_get_wtime();
    const double time_alloc = t1 - t0;

    // Compute SA (pure) time
    // Build suffix array and LCP array
    t0 = omp_get_wtime();
    build_suffix_array(text, sa, rank, cnt, next, bh, b2h);
    t1 = omp_get_wtime();
    const double time_sa = t1 - t0;

    // Compute LCP (pure) time
    t0 = omp_get_wtime();
    build_lcp(text, sa, rank, lcp);
    t1 = omp_get_wtime();
    const double time_lcp = t1 - t0;

    // LRS scan (post-processing)
    auto t_lrs_start = omp_get_wtime();

    int best_len = -1;
    int best_i = std::numeric_limits<int>::max(); // index in LCP (for first occurrence)
    int best_pos = std::numeric_limits<int>::max(); // associated SA position

#pragma omp parallel
    {
        int local_len = -1;
        int local_i = std::numeric_limits<int>::max();
        int local_pos = std::numeric_limits<int>::max();

#pragma omp for schedule(static)
        for (int i = 1; i < static_cast<int>(n); ++i)
        {
            const int len = lcp[i];
            if (len > local_len || (len == local_len && i < local_i) ||
                (len == local_len && i == local_i && sa[i] < local_pos))
            {
                local_len = len;
                local_i = i;
                local_pos = sa[i];
            }
        }

#pragma omp critical
        {
            if (local_len > best_len || (local_len == best_len && local_i < best_i) ||
                (local_len == best_len && local_i == best_i && local_pos < best_pos))
            {
                best_len = local_len;
                best_i = local_i;
                best_pos = local_pos;
            }
        }
    }

    int max_lcp = best_len;
    int pos_sa = (best_len >= 0 ? best_pos : 0);

    auto t_lrs_end = omp_get_wtime();
    const double time_lrs_scan = t_lrs_end - t_lrs_start;

    // Aggregate metrics
    const double time_compute_pure = time_sa + time_lcp;
    const double time_total_compute = time_alloc + time_compute_pure + time_lrs_scan; // excludes I/O time
    const double throughput_MBps = mb_from_bytes(n) / (time_compute_pure > 0 ? time_compute_pure : 1.0);
    constexpr double time_transfers_comm = 0.0; // no H<->D due to no GPU/MPI

    // Load baseline (average seq compute time for same size)
    const double T_seq = load_seq_baseline_for_mb(mb);
    const bool have_baseline = (T_seq > 0.0);
    const double speedup = have_baseline && time_compute_pure > 0 ? (T_seq / time_compute_pure) : 0.0;
    const double efficiency = have_baseline && p_threads > 0 ? (speedup / p_threads) : 0.0;
    const double memory_overhead_ratio = time_alloc / (time_alloc + time_compute_pure);

    // Report
    std::cout << std::fixed << std::setprecision(6);
    std::cout << "=== Suffix-Array + LCP (OpenMP) ===\n";
    std::cout << "size=" << mb << " MB   threads=" << p_threads << "\n";
    std::cout << "time_io=" << time_io << " s\n";
    std::cout << "time_alloc=" << time_alloc << " s\n";
    std::cout << "time_sa=" << time_sa << " s\n";
    std::cout << "time_lcp=" << time_lcp << " s\n";
    std::cout << "time_lrs_scan=" << time_lrs_scan << " s\n";
    std::cout << "time_compute_pure=" << time_compute_pure << " s\n";
    std::cout << "time_total_compute=" << time_total_compute << " s\n";
    std::cout << "time_transfers_comm=" << time_transfers_comm << " s\n";
    std::cout << "throughput=" << throughput_MBps << " MB/s\n";
    if (have_baseline)
    {
        std::cout << "speedup=" << speedup << "\n";
        std::cout << "efficiency=" << (efficiency * 100.0) << " %\n";
    }
    else
    {
        std::cout << "speedup=n/a (no baseline)\n";
        std::cout << "efficiency=n/a (no baseline)\n";
    }
    std::cout << "memory_overhead_ratio=" << (memory_overhead_ratio * 100.0) << " %\n";

    // Print LRS info (also in hex)
    std::cout << "max_lrs_len=" << max_lcp << "   pos=" << pos_sa << "\n";
    if (max_lcp > 0)
    {
        std::cout << "LRS (hex): ";
        for (int i = 0; i < max_lcp; ++i)
            std::cout << std::hex << std::uppercase << static_cast<int>(text[pos_sa + i]) << ' ';
        std::cout << std::dec << "\n";
    }
    else
        std::cout << "LRS (hex): (no repeated substring found)\n";

    return 0;
}
